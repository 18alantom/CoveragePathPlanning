  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>Document</title>
    </head>
    <style>
      html,
      body {
        margin: 0;
      }
      #map {
        width: 100vw;
        height: 90vh;
      }
      #controls {
        width: 100vw;
        height: 10vh;
      }
      #button {
        padding: 5px;
        margin: 5px;

      }

      #button1 {
        padding: 5px;
        margin: 5px;
      }

      #button2 {
        padding: 5px;
        margin: 5px;
      }

      #button3 {
        padding: 5px;
        margin: 5px;
      }

      #button4 {
        padding: 5px;
        margin: 5px;
      }

      #text{
        padding: 5px;
        margin: 5px;
        width: 60%; 
      }
    </style>
    <body>
      <div id="map"></div>
      <div id="controls">
        <input type="file" name="shapefile" id="shapefile" />
        <button id = "button"><b> ADD OBSTACLE </b>  </button>
        <button id = "button1"><b> CREATE OBSTACLE </b>  </button>
        <button id = "button2"><b> DELETE NODE </b>  </button>
        <button id = "button3"><b> PERFORM ANIMATION </b>  </button>
        <button id = "button4"><b> GRID </b>  </button>
        <button id = "button5"><b> SUBMIT </b>  </button>

        <input type="text" id="text" name="latlng">
      </div>
      <script>
        const POINT_NAME = "layers/POINT";
        const POLY_NAME = "layers/POLYGON";
        const OBSTACLE = "obstacle";
        const COVERAGE = "coverage";
        const fileSelector = document.getElementById("shapefile");
        let shapefile_polygon;
        let shapefile_geojson;
        let input;
        let poly_arr = [];
        let obst_arr = [];
        let path_arr = [];
        let midpoint;
        let bigarr=[];

        fileSelector.addEventListener("change", (e) => {
          const shapefile = e.target.files[0];
          const reader = new FileReader();
          reader.readAsArrayBuffer(shapefile);
          reader.onload = onLoadHandler;
        });
        function onLoadHandler() {
          shp(this.result).then((geojson) => {

            shapefile_geojson = geojson;
            // geojson_ = geojson;
            let coverageFeatureCollection = null;
            const obstacles = [];
            const coverage = [];
            // console.log(geojson);
            geojson.forEach((element) => {
              if (element.fileName == POINT_NAME) {
                map.data.addGeoJson(element);
              } else if ((element.fileName = POLY_NAME)) {
                element.features.forEach((feature) => {
                  // Why has he put this weird regex here?
                  const type = feature.properties.type.match(/[a-z]*/i)[0];
                  const coords = feature.geometry.coordinates[0];
                  if (type == COVERAGE) {
                    coverage.push(coords);
                  } else if (type == OBSTACLE) {
                    obstacles.push(coords);
                  } else {
                    bloop = type;
                  }
                });
              }
            });
            const poly = turf.polygon(coverage);
            const mask = turf.polygon(obstacles);
            //console.log(poly);

            // const finalCoverage = {
            //   type: "FeatureCollection",
            //   features: [turf.mask(poly, mask)],
            // };
            // map.data.addGeoJson(finalCoverage);
            
            // map.data.setStyle({
            //   fillColor: "lightblue",
            //   strokeWeight: 1,
            //   strokeColor: "blue",
            // });

            const p = turf.mask(poly, mask);
            // console.log(p);
            // console.log(mask);
            const len = mask.geometry.coordinates.length;
            const q = mask.geometry.coordinates;





            document.getElementById('button4').addEventListener("click", function()
            //SASHAAAAAAAAAAAA
            {
            	for (var z=0; z<poly.geometry.coordinates[0].length; z++)
            	{

	              bigarr.push([poly.geometry.coordinates[0][z][0], poly.geometry.coordinates[0][z][1]]);
            	}


	            let line = turf.lineString(bigarr);
	            let bbox = turf.bbox(line);
	            let bboxPolygon = turf.bboxPolygon(bbox);
	            //map.data.addGeoJson(bboxPolygon);
	            
	            let gridarr=[];

	            let s = console.log(bboxPolygon.geometry.coordinates[0].length);
	            
	            gridarr.push(bboxPolygon.geometry.coordinates[0][0][0]);
	            gridarr.push(bboxPolygon.geometry.coordinates[0][0][1]);
	            gridarr.push(bboxPolygon.geometry.coordinates[0][2][0]);
	            gridarr.push(bboxPolygon.geometry.coordinates[0][2][1]);
	            

	            console.log(gridarr);
	            
	            let height = 500                    //Metres
	            let angle = 70;
	            let angle1 = angle/2;
	            let diameter = 2* height * Math.tan(angle1);    //diaganol of the square
	            console.log(diameter);
	            let side = diameter/Math.sqrt(2);     //metres
	            console.log(side);
	            let cellSide=side/1000                //kilometers


	            //HAVERSINE FUNCTION 

	            Number.prototype.toRad = function()
	            {
	              return this*Math.PI /180;
	            }

	            var lat2 = bboxPolygon.geometry.coordinates[0][1][1]; 
	            var lon2 = bboxPolygon.geometry.coordinates[0][1][0]; 
	            var lat1 = bboxPolygon.geometry.coordinates[0][0][1]; 
	            var lon1 = bboxPolygon.geometry.coordinates[0][0][0];

	            var R = 6371; // km 
	            var x1 = lat2-lat1;
	            var dLat = x1.toRad();  
	            var x2 = lon2-lon1;
	            var dLon = x2.toRad();  
	            var a = Math.sin(dLat/2) * Math.sin(dLat/2) + 
	                Math.cos(lat1.toRad()) * Math.cos(lat2.toRad()) * 
	                Math.sin(dLon/2) * Math.sin(dLon/2);  
	            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
	            var d = R * c;                 //Km
	            console.log(d);                //km

	            let offset = d/cellSide;
	            console.log(d%cellSide);
	            
	            if(d%cellSide==0)
	            {
	                let options = {units: 'kilometers'};
	                let squareGrid = turf.squareGrid(gridarr, cellSide, options);
	                console.log(squareGrid);
	                map.data.addGeoJson(squareGrid);
	            }
	            else
	            {
	                //TODO: MAKE CHANGES HERE (INVERSE HAVERSINE FUNCTION)
	                let options = {units: 'kilometers'};
	                let squareGrid = turf.squareGrid(gridarr, cellSide, options);
	                console.log(squareGrid);
	                map.data.addGeoJson(squareGrid);

	                console.log("Else Block");
	                //console.log(squareGrid.features);
	                shapefile_geojson.push(squareGrid.features);
	                console.log(shapefile_geojson);
	            }
            });
            
            

          //let bbox = [ 72.79214859008789, 18.920089944412993, 72.84896850585938, 19.025283423553358];
          //let cellSide = 1;
  

            
          //SASHHHHHHHHHHHHHHHHHHHHAAAAAAAAA




            for(var i=0; i< p.geometry.coordinates[1].length; i++)
            {
              var temp = {lng: p.geometry.coordinates[1][i][0], lat: p.geometry.coordinates[1][i][1]}
              poly_arr.push(temp);
            }

            
            path_arr.push(poly_arr);

            for(var j=0; j< len; j++)
            {
              for(var i=(q[j].length) - 1; i>=0 ; i--)
              {                
                var ob_temp = {lng: q[j][i][0], lat: q[j][i][1]}
                obst_arr.push(ob_temp);
              }
              path_arr.push(obst_arr);
              //console.log(path_arr);
              obst_arr = [];
            }
            
            midpoint = turf.centroid(poly);

            shapefile_polygon = new google.maps.Polygon({
            paths: path_arr,
            strokeColor: "#FF0000",
            strokeOpacity: 0.8,
            strokeWeight: 3,
            fillColor: "#FF0000",
            fillOpacity: 0.35
          });

          shapefile_polygon.setMap(map);


          });

        }
      </script>
      <script src="https://unpkg.com/shpjs@latest/dist/shp.js"></script>
      <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
      <script>
        let map;
        let arr = [];
        let reverse_arr = [];
        let obs_marker;
        let obs_marker_arr = [];
        let ani_marker;
        let ani_marker_arr = [];
        let ani_arr = [];

        let temp = 'yash';

        const mapContainerDiv = document.getElementById("map");
        function initMap() {
          const postSIHParty = {
            lng: 72.88804829120636,
            lat: 19.080222794769302,
            zoom : 14
          };
          map = new google.maps.Map(mapContainerDiv, { zoom: 12, center: postSIHParty });
          const marker = new google.maps.Marker({ map: map, zoom:14, position: postSIHParty });

          

            //let bbox = [-95, 30 ,-85, 40];
           //let bbox = [ 72.79214859008789, 18.920089944412993, 72.84896850585938, 19.025283423553358];



          // Create the initial InfoWindow.
          var infoWindow = new google.maps.InfoWindow(
          {
            content: 'Click on ADD OBSTCALE to get Lat/Lng!', position: postSIHParty
          });
              
          infoWindow.open(map);

          document.getElementById('button').addEventListener("click", function()
          {
            shapefile_polygon.addListener('click', function(mapsMouseEvent) {
              // Close the current InfoWindow.
              infoWindow.close();
              // Create a new InfoWindow.
              infoWindow = new google.maps.InfoWindow({position: mapsMouseEvent.latLng});
              infoWindow.setContent(mapsMouseEvent.latLng.toString());
              infoWindow.open(map);
              const lat = mapsMouseEvent.latLng.lat();
              const lng = mapsMouseEvent.latLng.lng();

              obs_marker = new google.maps.Marker({
                position: mapsMouseEvent.latLng,
                map: map
              });
              obs_marker_arr.push(obs_marker);

              arr.push({lng: parseFloat(lng), lat: parseFloat(lat)});
              
              document.getElementById('text').value = arr.map(e=>`{${e.lat}, ${e.lng}} `).join(" ");
                
            });
          });
          
          document.getElementById('button1').addEventListener("click", function()
          {

            path_arr.push(arr);
            for (var i = 0; i < obs_marker_arr.length; i++) {
              obs_marker_arr[i].setMap(null);
            }       


            const pol = arr.map(p => [p.lat,p.lng]);
            pol.push(pol[0])
            const shapefileFeature = turf.polygon([pol]);
            console.log(shapefileFeature);

            for (var i=0; i<shapefile_geojson.length; i++)
            {
              if(shapefile_geojson[i].fileName == POLY_NAME)
              {
                shapefile_geojson[1].features.push(shapefileFeature);
              }
            }
            console.log(shapefile_geojson);


            obs_marker_arr = [];
            shapefile_polygon.setMap(null);
            shapefile_polygon = new google.maps.Polygon({
              paths: path_arr,
              strokeColor: "#FF0000",
              strokeOpacity: 0.8,
              strokeWeight: 3,
              fillColor: "#FF0000",
              fillOpacity: 0.35
            });


            shapefile_polygon.setMap(map);
            arr = [];
            document.getElementById('text').value = arr.map(e=>`{${e.lat}, ${e.lng}} `).join(" ");        
          });

          document.getElementById('button2').addEventListener("click", function()
          {
            arr.pop();
            document.getElementById('text').value = arr.map(e=>`{${e.lat}, ${e.lng}} `).join(" ");
          });

          document.getElementById('button3').addEventListener("click", function()
          {
	          

	          // Define the symbol, using one of the predefined paths ('CIRCLE')
	          // supplied by the Google Maps JavaScript API.
	          const lineSymbol = {
	              path: google.maps.SymbolPath.CIRCLE,
	              scale: 8,
	              strokeColor: "#393"
	          };

	          var path1= [{ lat:18.943041396461133, lng: 72.82522905545463 }, { lat:18.942107797981365, lng:  72.83200967984428 }, 
	                      { lat:18.936506097471703, lng: 72.83329714017142}, { lat: 18.935613055385847, lng: 72.82535780148734 } ]

	          var path2= [{ lat:18.957065859327418, lng: 72.82310881341961 }, { lat:18.957512323578108, lng:  72.83302225793865 }, 
	                      { lat:18.951748784128412, lng: 72.83572592462566}, { lat:18.957065859327418, lng: 72.82310881341961 } ]


	          var path = [path1, path2];

	            // Create the polyline and add the symbol to it via the 'icons' property.

	          for(let i = 0; i< path.length; i++)
	          {
	            const line = new google.maps.Polyline({
	              path: path[i],        
	              icons: [
	                  {
	                    icon: lineSymbol,
	                    offset: "100%"
	                  }
	              ], 
	              map: map,
	              
	            });

	            line.setMap(map);
	            animateCircle(line);
	          }

          }); 

          document.getElementById('button5').addEventListener("click", function()
          {
                var entry = shapefile_geojson;
                console.log(entry);

                fetch(`${window.origin}/shconv_2/create-entry`, {
		                method: "POST",
		                credentials: "include",
		                body: JSON.stringify(entry),
		                cache: "no-cache",
		                headers: new Headers({
		                  "content-type": "application/json"
		               })
		            })
		            .then(function (response) {
    		        if (response.status !== 200) {
    		          console.log(`Looks like there was a problem. Status code: ${response.status}`);
    		          return;
    		        }
    		        response.json().then(function (data) {
    		          console.log(data);
    		        });
    		       })
    		      .catch(function (error) {
    		        console.log("Fetch error: " + error);
    		      });
          }); 
          
          function animateCircle(line) {
            let count = 0;
            window.setInterval(() => {
              count = (count + 1) % 200;
              const icons = line.get("icons");
              icons[0].offset = count / 2 + "%";
              line.set("icons", icons);
            }, 40);
          }
      }

      </script>
      <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAkLQlSCLpYWPwDRI2Sjbnpk4DVkRpneSU&callback=initMap"></script>
      <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>
    </body>
  </html>
